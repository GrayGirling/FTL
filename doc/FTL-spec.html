<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=windows-1252"/>
	<title>FTL</title>
	<meta name="generator" content="LibreOffice 6.3.5.2 (Windows)"/>
	<meta name="author" content="Gray Girling"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="2020-04-17T23:32:32.155000000"/>
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<style type="text/css">
		h2 { border: none; padding: 0cm }
		h2.cjk { font-family: "NSimSun" }
		h2.ctl { font-family: "Lucida Sans" }
		pre { margin-left: 1cm; margin-top: 0.18cm; margin-bottom: 0.18cm; background: #eeeeee; border: none; padding: 0cm }
		pre.cjk { font-family: "NSimSun", monospace }
		h3.cjk { font-family: "NSimSun" }
		h3.ctl { font-family: "Lucida Sans" }
		h4.cjk { font-family: "NSimSun" }
		h4.ctl { font-family: "Lucida Sans" }
		h1.cjk { font-family: "NSimSun" }
		h1.ctl { font-family: "Lucida Sans" }
	</style>
</head>
<body lang="en-GB" dir="ltr"><h1 class="western" align="center">FTL</h1>
<h2 class="western" align="left">Language Design</h2>
<p align="left">The cornerstone construct in FTL is a closure, which
can be specified using the following syntax (which will be extended
below)</p>
<pre class="western" style="text-align: left">&lt;closure&gt; <span lang="zxx">:</span>:= '[' &lt;symbol&gt; ']' '::' &lt;code-expression&gt;</pre><p align="left">
where &lt;code&gt; is a normal expression that evaluates to a code
value, which could be a literal value such as</p>
<pre class="western" style="text-align: left">&lt;code&gt; ::= '{' &lt;code-item&gt;* '}'</pre><p align="left">
The &lt;code-items&gt; in the code primarily consist of symbols whose
meaning is determined by the environment in which the code is
executed. &nbsp;FTL implements an environment as an ordered set of
&quot;bound&quot;&nbsp;symbol-value pairs in which a value can be
found from a given symbol; and an &quot;unbound&quot; symbol which
has not yet been assigned a value.<br/>
When an argument is applied
to a closure a substitution of the unbound symbol with the value
given by &lt;expression&gt; is effected:</p>
<pre class="western" style="text-align: left">&lt;substitution&gt; ::= &lt;closure&gt; &lt;expression&gt;</pre><p align="left">
in which the resulting closure value &lt;substitution&gt;
incorporates an environment in which the unbound &lt;symbol&gt; in
the &lt;closure&gt; is paired with the value of the &lt;expression&gt;.
&nbsp;When the resulting closure is subsequently invoked</p>
<pre class="western" style="text-align: left">&lt;invocation&gt; := &lt;closure-expression&gt; '!'</pre><p align="left">
the code of the closure is interpreted in this environment so that
the bound values are available within the&nbsp;code. <br/>
<br/>
So,
conceptually a closure value is composed of three parts</p>
<ol>
	<li><p align="left" style="margin-bottom: 0cm">an ordered
	environment stack in which the most recently entered symbol values
	take priority over former values for the same symbol when they are
	sought 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">an optional unbound
	symbol 
	</p>
	<li><p align="left">a code value 
	</p>
</ol>
<p align="left">As a generalization of the simple &lt;closure&gt;
syntax above the part of the syntax before '<font face="monospace">::</font>'
</p>
<pre class="western" style="margin-left: 4.71cm; text-align: left">'[' &lt;symbol&gt; ']'</pre><p align="left">
is treated as a literal environment that may be generalized to an
&lt;environment-expression&gt; - the '<font face="monospace">::</font>'
being an operator that binds an environment to some code, or - more
generally - extends the environment in an existing closure with the
environment given.<br/>
<br/>
It is often the case that the execution
environment at the point of closure definition is required to be part
of the closure's own environment. &nbsp;This can be achieved by using
the '<font face="monospace">:</font>' operator in place of '<font face="monospace">::</font>'.&nbsp;
That is, a closure formed using</p>
<pre class="western" style="text-align: left">&lt;environment-expression&gt; '::' &lt;code-expression&gt;</pre><p align="left">
creates a closure with whose environment is exactly what is specified
in the &lt;environment-expression&gt;, but 
</p>
<pre class="western" style="text-align: left">&lt;environment-expression&gt; ':' &lt;code-expression&gt;</pre><p align="left">
also includes the current environment at the point of definition plus
the environment in &lt;environment-expression&gt;.<br/>
<br/>
Thus
the full syntax for a closure expression is:</p>
<pre class="western" style="margin-left: 4.71cm; text-align: left">&lt;closure&gt; ::= (&lt;environment-expression&gt; [ '::' | ':' ])* &lt;code-expression&gt;</pre><p align="left">
where either expression may involve literals, brackets, substitution,
invocation etc. &nbsp;One option for an &lt;environment-expression&gt;
is a &lt;closure&gt;, which, when used in this way refers only to the
environment part of the closure.</p>
<h2 class="western" align="left"><a name="mozTocId409702"></a>Syntactic
Sugar</h2>
<p align="left">The above specification is sufficient to provide all
the language's, typing, data structuring and code control primitives
as well as its object-orientated features. &nbsp;However in order to
reduce the complexity of the code there is syntax to simplify certain
idioms.</p>
<h3 class="western" align="left"><a name="mozTocId280832"></a>Creating
Bindings</h3>
<p align="left">This syntax 
</p>
<pre class="western" style="text-align: left"> '[' &lt;symbol2&gt; ']' '::' '[' &lt;symbol1&gt; ']' '::' &lt;code-expression&gt;</pre><p align="left">
(in which '<font face="monospace">::</font>' binds more tightly to
the right) can be replaced by:</p>
<pre class="western" style="text-align: left">'[' &lt;symbol1&gt;, &lt;symbol2&gt; ']' '::' &lt;code-expression&gt;</pre><p align="left">
and in general any number of unbound symbols can be placed in an
environment. &nbsp;Note,&nbsp;that values associated with <font face="monospace">&lt;symbol2&gt;</font>
take precedence over those of <font face="monospace">&lt;symbol1&gt;</font>
when both symbols have the same name. &nbsp;The first substitution
applied to these expressions will bind <font face="monospace">&lt;symbol1&gt;</font>.<br/>
<br/>
This
syntax 
</p>
<pre class="western" style="text-align: left"> '[' &lt;symbol&gt; ']' '::' &lt;code-expression&gt; &lt;value&gt;</pre><p align="left">
can be replaced by:</p>
<pre class="western" style="text-align: left">'[' &lt;symbol&gt; '=' &lt;value&gt; ']' '::' &lt;code-expression&gt;</pre><p align="left">
and in general</p>
<pre class="western" style="text-align: left">'[' &lt;sym_m&gt; ']' '::' ... '::' '[' &lt;sym_1&gt; ']''::' &lt;code-expression&gt; &lt;val_1&gt; ... &lt;val_n&gt;</pre><p align="left">
<br/>
can be replaced by</p>
<pre class="western" style="text-align: left">'[' &lt;sym_1&gt; '=' &lt;val_1&gt; ',' ... ',' &lt;sym_n&gt; = &lt;val_n&gt; ',' ... &lt;sym_m&gt; ']' '::' &lt;code-expression&gt;</pre><p align="left">
Note that each <font face="monospace">&lt;val_i&gt;</font> is still
evaluated in the environment outside the closure (in which none of
the <font face="monospace">&lt;sym_i&gt;</font> symbols have been
set). &nbsp; The symbols with an associated '=' will be bound
symbols, and those without will be unbound. <br/>
<br/>
In addition
this environment syntax 
</p>
<pre class="western" style="text-align: left">'[' &lt;sym_1&gt; '=' &lt;val_1&gt; ',' ... ',' &lt;sym_n&gt; = &lt;val_n&gt; ',' ... &lt;sym_m&gt; ']'</pre><p align="left">
specifies a first-class element in the language that can be used as a
value anywhere. &nbsp;Note that, to simplify implementation, no bound
symbols can be specified following the first unbound symbol in the
specification.</p>
<h3 class="western" align="left"><a name="mozTocId807267"></a>Obtaining
Bound Values in Closures</h3>
<p align="left">This syntax 
</p>
<pre class="western" style="text-align: left">&lt;closure&gt; '::' '{' &lt;symbol&gt; '}' '!' </pre><p align="left">
(which simply expands to the value of &lt;symbol&gt; in &lt;closure&gt;&rsquo;s
environment) can be replaced by</p>
<pre class="western" style="text-align: left">&lt;closure&gt; '.' &lt;<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">value</font></font>&gt;</pre><p align="left">
Currently &lt;value&gt;s are constrained to be either integers or
strings. For the sake of convenience strings can be provided as
symbols (with no associated quotes) if they have the syntax of an
identifier.</p>
<p align="left">In addition the following syntax can be used to
create a symbol value from an expression</p>
<pre class="western" style="text-align: left">'&lt;closure&gt; '.' '(' &lt;expression&gt; ')'</pre><p align="left">
where, for example, an expression returning an integer or a string is
converted to a symbol before use. 
</p>
<p align="left">When symbols are needed for the local environment it
is possible to use these syntaxes with no closure. That is, the
following are replaced by the value of a symbol in the current
environment:</p>
<pre class="western" style="text-align: left">'.' &lt;<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">value</font></font>&gt;

'.' '(' &lt;expression&gt; ')'</pre><p align="left">
<br/>
<br/>

</p>
<h3 class="western" align="left"><a name="mozTocId495578"></a>Integers</h3>
<p align="left">Although it would theoretically be possible to create
an environment defining all the values for 64 bit integers:</p>
<pre class="western" style="text-align: left">{ int = { 0=&lt;0 value&gt;, 1=&lt;1 value&gt;, .... 9223372036854775807=&lt;9223372036854775807 value&gt; }:
[ int: [.... main body of program ....] ] 
!</pre><p align="left">
this step is assumed as part of the runtime library - thus all
numeric symbols are interpreted with their expected values (unless
overridden by higher priority definitions).&nbsp; 
</p>
<h3 class="western" align="left"><a name="mozTocId541092"></a>Vectors</h3>
<p align="left">This syntax</p>
<pre class="western" style="text-align: left">[ 0=expr0, 1=expr1, ... N=exprN ]</pre><p align="left">
can be replaced by</p>
<pre class="western" style="text-align: left">&lt; expr0, expr1, ... exprN &gt;</pre><p align="left">
or ,where not all of the indices are consecutive, this may be broken
into subseries</p>
<pre class="western" style="text-align: left">&lt; &lt;int_i&gt;=expr_i, expr_i+1, ..., &lt;int_j&gt;=expr_j, expr_j+1..., ... &gt;</pre><p align="left">
i.e. using the general syntax</p>
<pre class="western" style="text-align: left">'&lt;' [ [&lt;integer&gt;=]&lt;expression&gt; [',' [&lt;integer&gt;=]&lt;expression&gt; ]* ] '&gt;' </pre><p align="left">
<br/>
Vectors that are simple numeric series can be represented</p>
<pre class="western" style="text-align: left">'&lt;' [&lt;expression-int_first&gt; [ &lt;expression-int_second&gt; ]] '..' [ &lt;expression-int_last&gt; ] '&gt;'</pre><p align="left">
where, if &lt;expression-int_second&gt; is missing an integer one
greater than&nbsp;&lt;expression-int_first&gt; is used, and if
&lt;expression-int_first&gt; is missing the number 1 is used. &nbsp;
Thus, there would be the 42 numbers from one to forty-two indexed by
the integers 0 to 41 in</p>
<pre class="western" style="text-align: left">&lt;..42&gt;</pre><p align="left">
so that the following would have value 10</p>
<pre class="western" style="text-align: left">&lt;..42&gt;.11</pre><h3 class="western" align="left">
Code Concatenation</h3>
<p align="left">The infix operator &quot;;&quot; is available in a
code object to ignore its left-hand value and replace it with its
right (if there is one). &nbsp;Thus the value of 
</p>
<pre class="western" style="text-align: left">&lt;expression 1&gt; ; &lt;expression 2&gt; ; ... ; &lt;expression n&gt;</pre><p align="left">
is &lt;expression n&gt;. &nbsp;And the value of 
</p>
<pre class="western" style="text-align: left">&lt;expression 1&gt; ; &lt;expression 2&gt; ; ... ;</pre><p align="left">
is the special empty value &quot;<font face="monospace">NULL</font>&quot;
(which is therefore a name for the value of &quot;<font face="monospace">{}!</font>&quot;)</p>
<h3 class="western" align="left">Boolean Expressions</h3>
<p align="left">The standard environment in FTL includes two
&quot;built-in&quot; values &quot;<font face="monospace">TRUE</font>&quot;
and &quot;<font face="monospace">FALSE</font>&quot;. &nbsp;In
principle they are implemented as if they had been defined:</p>
<pre class="western" style="text-align: left">TRUE = [val]::{val!}
FALSE = [val]::{FALSE}</pre><p align="left">
That is, <font face="monospace">TRUE</font> is a closure that will
execute its argument and <font face="monospace">FALSE</font> is a
closure that will discard its argument and return <font face="monospace">FALSE</font>
instead. &nbsp;Thus if a value that is either <font face="monospace">TRUE</font>
or <font face="monospace">FALSE</font> is given code as an argument: 
</p>
<pre class="western" style="text-align: left">&lt;true_or_false&gt; { &lt;code&gt; }!</pre><p align="left">
the result will be either the result of the code's execution or the
value <font face="monospace">FALSE</font>. &nbsp;Thus the code is
conditionally executed.&nbsp; 
</p>
<h2 class="western" align="left"><a name="mozTocId347665"></a>Syntactic
Details</h2>
<p align="left">The format of the source file is not specified since
it is normal for FTL expressions to be embedded in an external
application. &nbsp;Typically such an application will apply such
formatting conventions as:</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">discard of commented
	out lines (e.g. those beginning '#') 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">concatenation of
	lines ending with an escape (e.g. '\') 
	</p>
	<li><p align="left">expansion of textual substitutions (e.g. base on
	FTL expressions) introduced with an expansion escape (e.g. '$') 
	</p>
</ul>
<p align="left">The characters '#', '\' and '$' are not used as part
of FTL syntax. 
</p>
<pre class="western" style="text-align: left">&lt;code-item&gt; ::= &lt;symbol&gt; | &lt;string&gt; |
                '[' | ']' | '{' | '}' | '&lt;' | '&gt;' | '(' | ')' |
                '!' | '&amp;' | '~' | '@' | 
                ';' | ',' | ':' | '.'
&lt;symbol&gt; ::= &lt;integer&gt; | &lt;identifier&gt;
&lt;integer&gt; ::= &lt;digit&gt;+
&lt;identifier&gt; ::= &lt;common_identifier&gt; | &lt;builtin_identifier&gt;
&lt;common_identifier&gt; ::= &lt;alphabetic&gt; (&lt;alphabetic&gt; | '_' | &lt;digit&gt;)*
&lt;builtin_identifier&gt; ::= '_' &lt;digit&gt;+ </pre><p align="left">
The precedence of the various operators outlined above is specified
as part of the syntax for an expression: 
</p>
<pre class="western" style="text-align: left">&lt;expression&gt; ::= (&lt;index&gt; '=')* &lt;invocation&gt;
&lt;invocation&gt; ::= (&lt;substitution&gt; ['!']*)+ 
&lt;substitution&gt; ::= &lt;retrieval&gt;+
&lt;retrieval&gt; ::= &lt;closure&gt;['.' &lt;index&gt;]*
&lt;closure&gt; ::= (&lt;base&gt; [':' | '::'])* &lt;base&gt;
&lt;base&gt; ::= '(' &lt;expression&gt; ')' |
           &lt;code&gt; |
           &lt;id_environment&gt; |
           &lt;identifier&gt; |
           &lt;vector&gt; |
           &lt;type_literal&gt;
&lt;code&gt; ::= '{' &lt;expression_list&gt; '}'
&lt;expression_list&gt; ::= &lt;expression&gt; (';' &lt;expression&gt;)* [';']
&lt;id_environment&gt; ::= '[' [&lt;binding_list&gt; | &lt;binding_list&gt; ',' &lt;unbound_list&gt; | &lt;unbound_list&gt;] ']' 
&lt;binding_list&gt; ::= [&lt;binding&gt; (',' &lt;binding&gt;)*]  
&lt;unbound_list&gt; ::= &lt;index&gt; (',' &lt;index&gt;)*
&lt;binding&gt; ::= &lt;index&gt; '=' &lt;invocation&gt;&lt;vector&gt; ::= '&lt;' &lt;implied_series&gt; | &lt;series&gt; '&gt;'
&lt;index&gt; ::= &lt;identifier&gt; | &lt;type_literal&gt;
&lt;type_literal&gt; ::= &lt;integer&gt; |
                   &lt;string&gt; 
&lt;series&gt; ::= &lt;expression&gt;*
&lt;implied_series&gt; ::= [&lt;expression&gt; [&lt;expression&gt;]] '..' [&lt;expression&gt;]</pre><h2 class="western" align="left">
Compilation and Semantics</h2>
<p align="left">The semantics of the language can partly be specified
by describing how an expression that is an equivalent canonical
representation of a code value can be obtained (i.e. how a code value
can be &quot;compiled&quot;). &nbsp;This specification requires the
premise of a small number of built-in closures:</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm"><b>substitute</b>:
	&nbsp;Closure x Value -&gt; Closure<br/>
Returns a closure in which
	the first unbound variable of the argument closure is bound to the
	value 
	</p>
	<li><p align="left" style="margin-bottom: 0cm"><b>cat</b>: Closure x
	Closure -&gt; Value<br/>
Evaluates both closures (which must have no
	unbound variables) and returns the value of the second 
	</p>
	<li><p align="left" style="margin-bottom: 0cm"><b>eval</b>: Closure
	-&gt; Value<br/>
Evaluates the closure and returns its value 
	</p>
	<li><p align="left" style="margin-bottom: 0cm"><b>push</b>: Env x
	Env -&gt; Env<br/>
Returns an environment in which the names, value
	mappings specified in both environments are available and in which
	any mapping in the second takes precedence when its name is also
	specified in the first 
	</p>
	<li><p align="left" style="margin-bottom: 0cm"><b>lookup</b>: Env x
	Value -&gt; Value<br/>
Returns the value associated with the
	argument value (interpreted as a name) in the environment provided 
	</p>
	<li><p align="left"><b>assign</b>: Env x Value x Value -&gt;
	Env<br/>
Returns the environment in which the mapping named by the
	first value now maps on to the new (second) value provided 
	</p>
</ul>
<p align="left">The algorithm is specified as a series of &quot;rewrite&quot;
rules that can be used to convert a code value into a &quot;simpler&quot;
expression involving code values until the simplest (a code value
with only a single symbol in it) can be replaced by the use of
the&nbsp;<b>lookup</b> function above.<br/>
<br/>
As a simple example
of compilation observe that 
</p>
<pre class="western" style="text-align: left">{ function! }</pre><p align="left">
(in the execution environment) could be &quot;compiled&quot; to the
replacement 
</p>
<pre class="western" style="text-align: left"><b>eval</b> function</pre><p align="left">
because this is a closure value that has yet to be executed. &nbsp;The
expressions are equivalent because both of the following would yield
the same result:</p>
<pre class="western" style="text-align: left">{ function! }!
<b>eval</b> function!</pre><p align="left">
The rules use 'E' to specify an execution environment, and 'X' and
'Y' to specify symbols parsing to the syntax relevant to the operator
each rule deals with. &nbsp;They are as follows:</p>
<ol>
	<li><p align="left" style="margin-bottom: 0cm">E::{&lt;index&gt;} =&gt;
	<b>lookup</b> E &lt;index&gt; 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">E::{ X::Y } =&gt;
	(<b>eval</b> E::{X})::{Y} 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">E::{ X:Y } =&gt;
	(<b>eval</b> (<b>push</b> E (<b>eval</b> E::{X})))::{Y} 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">E::{ X.Y } =&gt; <b>eval</b>
	((<b>eval</b> E::{X})::{Y}) 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">E::{ X Y } =&gt;
	<b>substitute</b> E::{X} E::{Y} 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">E::{ X! } =&gt; <b>eval</b>
	E::{X} 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">E::{ X=Y } =&gt; <b>cat</b>
	(<b>assign</b> E X&nbsp;E::{Y})&nbsp;E::{Y} 
	</p>
	<li><p align="left">E::{ X;Y } =&gt; <b>cat</b> E::{X} E::{Y} 
	</p>
</ol>
<p align="left">Simplification rules can be applied during this
process when the environment is known to be constant or when the
values associated with names in environments are known to be
constant. &nbsp;If both compilation and simplification is applied to
expressions the cost of execution can be significantly decreased. 
</p>
<h2 class="western" align="left"><a name="mozTocId878738"></a>Techniques</h2>
<p align="left">This section illustrates the expressive power of the
language so far introduced. In particular it shows how many
constructs present in other languages can be emulated.</p>
<h3 class="western" align="left"><a name="mozTocId431017"></a>Function
calls</h3>
<p align="left">Closures have an obvious relation to
procedures/procedures - the unbound symbols act as formal parameters
and the code becomes the body of the procedure. &nbsp;In effect
functions are curried - closure values being available at
intermediate stages when not all of the arguments have been provided.
&nbsp;For example</p>
<pre class="western" style="text-align: left">square = [n]: {<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">mul</font></font> n n !}
length = [width, height]: { sqroot (add (square width !) (square height !) !) ! }</pre><p align="left">
Notice that</p>
<pre class="western" style="text-align: left">square 5 </pre><p align="left">
simply returns the code in the binding that would evaluate 5 times 5
if it were executed. &nbsp;If its value were printed it would be</p>
<pre class="western" style="text-align: left">[n=5]: {<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">mul</font></font> n n !}</pre><p align="left">
(Note: in the implementation, there is no primitive that will print
the value in this format. Printing the value as &ldquo;[]:{mul n n
!}&rdquo;, where only unbound variables are shown, is more convenient
because of the large size of the environment associated with a
typical binding.)</p>
<p align="left">whereas printing the expression</p>
<pre class="western" style="text-align: left">square 5 !</pre><p align="left">
would produce the answer</p>
<pre class="western" style="text-align: left">25</pre><p align="left">
similarly 
</p>
<pre class="western" style="text-align: left">width4length = length 4</pre><p align="left">
simply assigns a binding which is similar to a function that adds
four squared to its argument:</p>
<pre class="western" style="text-align: left">[width=4, height]: { sqroot (add (square width !) (square height !) !) ! } </pre><p align="left">
The value of</p>
<pre class="western" style="text-align: left">width4length 3 !</pre><p align="left">
would be</p>
<pre class="western" style="text-align: left">5</pre><h3 class="western" align="left">
<a name="mozTocId146722"></a>Records</h3>
<p align="left">Closure bound variables can be used as the names in a
record. &nbsp;for example</p>
<pre class="western" style="text-align: left">point = [x=15, y=32]</pre><p align="left">
The fields can be accessed as follows:</p>
<pre class="western" style="text-align: left">radius = length point.x point.y !</pre><h3 class="western" align="left">
<a name="mozTocId434879"></a>If .. then .. else</h3>
<p align="left">Conditional execution of a single element of code
code is provided using boolean expressions returning TRUE or FALSE
(as described above). &nbsp;</p>
<pre class="western" style="text-align: left">too_big { 
  print &quot;not small enough&quot; !;
}!</pre><p align="left">
If the given code returns one of the values <font face="monospace">TRUE</font>
or <font face="monospace">FALSE</font>, a compound boolean expression
can be built up in which each item in the chain is executed only if
previous ones have evaluated to <font face="monospace">TRUE</font>:</p>
<pre class="western" style="text-align: left">&lt;true_or_false&gt; {&lt;boolean_expression&gt;}! {&lt;boolean_expression&gt;}! ... {&lt;boolean_expression&gt;}!</pre><p align="left">
Thus this construct can be used as a conditionally executed
&quot;and&quot;.<br/>
The standard environment also includes a
function &quot;<font face="monospace">invert</font>&quot; that
returns <font face="monospace">FALSE</font> only if its argument is
<font face="monospace">TRUE</font> and returns <font face="monospace">FALSE</font>
otherwise. &nbsp;When combined with the &quot;and&quot; functionality
above this provides a sufficient basis for the evaluation of any
boolean expression.<br/>
It would also be possible to select between
two (or more) elements of code by using the numeric values 0 and 1 to
represent a condition in a function that takes the condition and two
code values as arguments and choses which code value to execute
depending on the numeric argument. &nbsp;One such definition might
be:</p>
<pre class="western" style="text-align: left">if = [condition, if_part, else_part]: { 
      <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">condition != FALSE {if_part!}!; </font></font>
      <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">condition == FALSE {else_part!}!;</font></font> 
}</pre><p align="left">
which enables code to be written such as</p>
<pre class="western" style="text-align: left">if (<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">more</font></font> radius 1 !) {
    print &quot;here already\n&quot; !
}{
    print &quot;travelling some way\n&quot; !
}!</pre><p align="left">
Such a definition is not required, however, since the standard
environment in FTL includes an &quot;<font face="Courier New, monospace">if</font>&quot;
function which takes a <font face="monospace">TRUE</font> or <font face="monospace">FALSE</font>
value as an argument.</p>
<h3 class="western" align="left">Switch Statements</h3>
<p align="left">Given the semantics of <font face="monospace">TRUE</font>
and <font face="monospace">FALSE</font> it is possible to create a
switch-like construct such as:</p>
<pre class="western" style="text-align: left"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">switch</font></font> = [val, <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">val</font></font>codevec, default]:{
         if (inenv valcodevec val!) {valcodevec.(vec)!} {default!}!
}</pre><p align="left">
(where &ldquo;<font face="Courier New, monospace">inenv env value!</font>&rdquo;
is <font face="Courier New, monospace">TRUE</font> when the value is
bound in <font face="Courier New, monospace">env</font>) which
enables code such as this to be written:</p>
<pre class="western" style="text-align: left">switch n &lt;
    1 = {echo &quot;n is one&quot;!},
    2 = {echo &quot;n is two&quot;!},
    3 = {echo &quot;n is three&quot;!}
&gt; {echo &quot;n is unknown&quot;!}!;</pre><h3 class="western" align="left">
<a name="mozTocId937909"></a>For loops</h3>
<p align="left">Repetitive execution could be provided recursively by
a function that keeps decrementing its counter by one and applying
the counter to an argument block of code, e.g.</p>
<pre class="western" style="text-align: left">forn = [n, code]: {
         more n 0 ! {
             forn (<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">sub</font></font> n 1 !) code ! 
         }!;
         code n !;
       }</pre><p align="left">
which enables code to be written such as</p>
<pre class="western" style="text-align: left">forn 4 [n]: {
    print n!; print &quot; squared is &quot;!; print (squared n!) ! ; print &quot;\n&quot;!;
}!</pre><p align="left">
which will print out the squares from 0 to 4. 
</p>
<p align="left">Such a definition is not required, however, since the
standard environment in FTL includes an &quot;<font face="Courier New, monospace">for</font>&quot;
function which takes an environment and a closure value as an
argument and applies each binding in the environment to the closure
value.</p>
<h3 class="western" align="left"><a name="mozTocId737869"></a>Local
Variables</h3>
<p align="left">A code value may need to make use of additional
variables that are local to the body of the code. If there were an
external symbol named &lsquo;answer&rsquo; this function would have
the side-effect of updating it.</p>
<pre class="western" style="text-align: left"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">empty</font></font> = [<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">string</font></font>]: {
    answer = FALSE;
    (len string!) == 0 {answer = TRUE}!;
    answer
}</pre><p>
Local variables allow new variable instances to be used so that they
are not confused with existing ones. 
</p>
<p>This technique adds the local variables to the closure environment
and gives it an initial value:</p>
<pre class="western" style="text-align: left"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">empty</font></font> = [answer=<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">NULL</font></font>, <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">string</font></font>]: {
    answer = FALSE;
    (len string!) == 0 {answer = TRUE}!;
    answer
}</pre><p>
It has the benefit/disbenefit of making the value of &lsquo;answer&rsquo;
part of empty&rsquo;s state (accessible as &quot;<font face="Courier New, monospace">empty.answer</font>&quot;).
Note that the line &quot;<font face="Courier New, monospace">answer =
FALSE</font>&quot; can not be replaced by the initialization in the
closure&rsquo;s environment. After every invocation &quot;<font face="Courier New, monospace">empty.answer</font>&quot;
will take the value last assigned to it.</p>
<p>This technique executes a code sub-block as a separate closure
which has access to the new variable set its environment:</p>
<pre class="western" style="text-align: left"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">empty</font></font> = [<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">string</font></font>]: {
    [answer = FALSE]:{
        (len string!) == 0 {answer = TRUE}!;
        answer}!
}</pre><p>
It has the benefit/disbenefit of hiding the value of &quot;<font face="Courier New, monospace">answer</font>&quot;
from the user of &quot;<font face="Courier New, monospace">empty</font>&quot;.</p>
<p>The standard FTL library includes two functions &quot;<font face="Courier New, monospace">enter</font>&quot;
and &quot;<font face="Courier New, monospace">leave</font>&quot;
which place a new environment on the top of the stack and
(optionally) remove it, respectively. The use of &quot;<font face="Courier New, monospace">enter</font>&quot;
on its own is effectively equivalent to the code above:</p>
<pre class="western" style="text-align: left"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">empty</font></font> = [<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">string</font></font>]: {
    enter [answer = FALSE]!;
    (len string!) == 0 {answer = TRUE}!;
    answer
}</pre><p>
It behaves the same way that the sub-block closure has above.</p>
<h3 class="western" align="left">Objects and their Methods</h3>
<p align="left">A record that combines both internal state and a
number of methods that interact with that state can be constructed
using a closure. &nbsp;For example:</p>
<pre class="western" style="text-align: left"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">vect</font></font> = [x,y]:{
    echo &quot;New point&quot;!;
    [   print = []:{
            echo &quot;&lt;\$x,\$y&gt;&quot;!
        },
        xcoord = []:{x},
        ycoord = []:{y},
        add = [pt]:{
            vect (add x (pt.xcoord!)!) (add y (pt.ycoord!)!)!
        },
        <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">sub</font></font> = [pt]:{
            vect (<font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">sub</font></font> x (pt.xcoord!)!) (sub y (pt.ycoord!)!)!
        }
    ]
};
p = <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">vect</font></font> 4 5!;
p.print!;
q = <font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">vect</font></font> 2 1!;
(p.sub q!).print!</pre><p align="left">
would print out &quot;New point&quot;, &quot;&lt;4,5&gt;&quot;, &quot;New
point&quot; and then &quot;New point&quot;, &quot;&lt;2,4&gt;&quot;.
&nbsp;There are some things to note</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">The &quot;methods&quot;
	must be closures, not code objects (hence the syntax &quot;<font face="monospace">[]:</font>&quot;
	preceding the code values), only closures inherit the environment at
	the point of their definition. 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">The &quot;object&quot;
	returned has the arguments, <font face="monospace">x</font> and <font face="monospace">y</font>,
	from point bound into it but does not contain them in the record
	returned: using <font face="monospace">p.x</font> and <font face="monospace">p.y</font>
	would return an error because <font face="monospace">x</font> and <font face="monospace">y</font>
	are not parts of this record (this is why the methods <font face="monospace">xcoord</font>
	and <font face="monospace">ycoord</font> were defined). 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">(However, because <font face="Monospace">x</font>
	and <font face="Monospace">y</font> are bound into the methods it is
	possible to use <font face="Monospace">p.add.x</font> and <font face="Monospace">p.add.y</font>
	for example!)</p>
	<li><p align="left">If there is any initialization for the object to
	be performed it can be done in a code part to the definition of
	&quot;<font face="monospace">point</font>&quot;. 
	</p>
</ul>
<h3 class="western" align="left">Argument Passing</h3>
<p align="left">Although not built in to the language, methods of
parameter passing can be emulated as follows.</p>
<h4 class="western" align="left">Call by value</h4>
<p align="left">In call by value an expression is evaluated and the
resulting value is bound in to the closure invocation. 
</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">example actual
	argument syntax: in<font face="monospace">(add</font> <font face="monospace">a
	b!)</font> 
	</p>
	<li><p align="left">example formal argument read in closure body
	when bound as &quot;x&quot;: <font face="monospace">x</font> 
	</p>
</ul>
<h4 class="western" align="left">Call by name</h4>
<p align="left">In call by name the expression passed in to the
invocation is re-evaluated in the context of the invocation on each
use.</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">Example actual
	argument syntax: <font face="monospace">{add</font> <font face="monospace">a
	b!}</font> 
	</p>
	<li><p align="left">example formal argument read in closure body
	when bound as &quot;x&quot;: <font face="monospace">(x!)</font> 
	</p>
</ul>
<h4 class="western" align="left">Call by reference &ndash; in &ndash;
function technique</h4>
<p align="left">In call-by-reference &quot;in&quot;, the variable
passed in to the invocation is read indirectly on on each use.</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">Example actual
	argument syntax:&nbsp;<font face="monospace">[]:{a}</font> 
	</p>
	<li><p align="left">example formal argument read in closure body
	when bound as &quot;x&quot;: <font face="monospace">(x!)</font> 
	</p>
</ul>
<h4 class="western" align="left">Call by reference &ndash; in out &ndash;
object technique</h4>
<p align="left">In call by-reference &quot;in out&quot;, the variable
passed in to the invocation is read indirectly on each use and can
also be written to indirectly. 
</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">example actual
	argument syntax:&nbsp;<font face="monospace">[get=[]:{a},
	set=[x]:{a=x}]</font> 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">example formal
	argument read in closure body when bound as &quot;x&quot;: <font face="monospace">(x.get!)</font>
		</p>
	<li><p align="left">example formal argument write in closure body
	when bound as &quot;x&quot;: <font face="monospace">x.set 3!</font> 
	</p>
</ul>
<h4 class="western" align="left">Call by reference &ndash; <font face="Liberation Serif, serif"><font size="3" style="font-size: 12pt"><b>vector</b></font></font>
technique</h4>
<p align="left">In call-by-reference &quot;in out&quot;, the variable
passed in to the invocation is read and written as the only element
in a vector.</p>
<ul>
	<li><p align="left" style="margin-bottom: 0cm">example actual
	argument syntax:&nbsp;<font face="monospace">&lt;a&gt;</font> 
	</p>
	<li><p align="left" style="margin-bottom: 0cm">example formal
	argument read in closure body when bound as &quot;x&quot;: <font face="monospace">x.0</font></p>
	<li><p align="left" style="margin-bottom: 0cm">example formal
	argument write in closure body when bound as &quot;x&quot;: <font face="monospace">x.0</font></p>
</ul>
<p align="left" style="margin-bottom: 0cm"><br/>

</p>
<h3 class="western" align="left">With Statement</h3>
<p align="left">Some languages have syntax which allows a block of
code to be entered in which the fields in a specific record to be
accessed directly by name (instead of using &lt;record&gt;.&lt;name&gt;
for example). This can be provided in the same way that locals are
dealt with (see above).</p>
<p>This technique executes a code sub-block as a separate closure
which has access to the new variable set its environment:</p>
<pre class="western">item_bill = [purchase]: {
    purchase:{
        total = items * unit_cost
    }!
};
item1 = [name=&quot;Cheese&quot;, total=NULL, items=3, unit_cost=200];
item_bill item1!;
print item1!;</pre><p align="left">
would print out &quot;[name=&quot;Cheese&quot;,total=600,items=3,unit_cost=200]&quot;.</p>
<p align="left"><br/>
<br/>

</p>
</body>
</html>